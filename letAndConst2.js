//块级作用域

//第一种场景，内层变量可能会覆盖外层变量
var tmp = new Date();
function f(){
  console.log(tmp); //undefined
  if(false){
    var tmp='hello world'; //变量提升，导致内层的覆盖了外层的
  }
}
f();


//用来计数的循环变量泄露为全局变量
var s = 'hello';
for(var i = 0;i < s.length;i++){
  console.log(s[i]);
}
console.log(i);//变量 i 只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量



//--------------------------------------------------- es6中的块级作用域------------------------------------------------------------
function f1(){
  let n = 5;
  if(true){
    let n = 10;
  }
  console.log(n);//5
}

//es6 允许块级作用域的任意嵌套
{{{
  {let instance = 'hello world'}
  //console.log(instance);//报错
  {let instance = 'hello world'}
}}}

// 2:块级作用域的出现，实际上使得获得广泛运用的立即执行函数表达式（IIFE）不再必要了
//IIFE写法
((function (){
  var tmp = ...;
  ....
})());

//块级作用域的写法
{
  let tmp = ...
  ...
}


//---------------------------------------------------块级作用域与函数声明-------------------------------

//es5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域中声明
if(true){
  function f(){}
}

try{
    function f(){}
}catch(e){
}
//但是浏览器没有这个规定，为了兼容以前的旧代码，还是支持在块级作用域
//中声明函数，因此上面两种情况都嫩运行，不会报错


//ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中
//函数声明语句的行为类似于let，在块级作用域之外不可引用。

function f2(){
  console.log('I am outside');
}
// ((function(){
//   if(false){
//     function f(){
//       console.log('I am inside');
//     }
//   }
//   f();
// })());  报错



//-----------------------------------------------do表达式-------------------------------------------------
let x = do{
  let t = f();
  t = t + 1;
}
//在上面代码中，x会得到整个块级作用域的返回值

//-----------------------------------------------const 用法-------------------------------------======

const a = [];
a.push('hello');
a.length = 0;
a = ['deva'];//报错

const foo = {};
foo.prop = 123;
foo.prop  //123;
foo = {}; //报错
//常亮 foo 储存的是一个地址，这个地址指向的是一个对象，不可改变的只是这个地址，即不能把 foo指向另外一个地址
//但是这个对象本身是可变的，所以依然可以为其添加新属性

//冻结对象的方法
const foo = object.freeze({});
//常规模式下，下面行不起作用
//严格模式时，该行会报错
foo.prop = 123;

//对象本身冻结，对象的属性也应该冻结，下面是一个将对象彻底冻结的函数
var constantize = (obj) =>{
  object.freeze(obj);
  object.keys(obj).forEach(key,i)=>{
    if(typeof obj[key] === 'object'){
      constantize(obj[key]);
    }
  }
}


//-----------------------------------------------顶层对象------------------------------------------------

//顶层对象，在浏览器环境下指的是window对象，Nod指的是global对象，es5之中，顶层对象的属性与全局变量是等价的

//es6为了改变顶层对象与全局变量挂钩，一方面规定，为了保持兼容性，var命令和function 命令声明的全局变量，依然是顶层对象的属性
//另一方面规定,let const class 命令声明的全局变量。不属于顶层对象的属性
































//
