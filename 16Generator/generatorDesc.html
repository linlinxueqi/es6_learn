<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>generator的基本介绍</title>
  </head>
  <body>
      1:for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。
      2: 这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。
      <script type="text/javascript">
          //1:简介
          // generator函数是es6提供的一种异步编程解决方案
          // generator函数有多种理解角度，从语法上，首先可以把它理解成generator函数是一个状态机，封装了多个内部状态
          // 执行generator函数会返回一个遍历器对象，

          // yield表达式，定义不同的内部状态（产出）
          function*  helloWorldGenerator(){
            yield 'hello';
            yield 'world';
            return 'ending';
          }
          var hw = helloWorldGenerator();
          //该函数有是三个状态，hello,world 和return语句
          // 调用generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象
          //代表generator函数的内部指针
          hw.next();//{value:'hello',done:false};
          hw.next();//{value:'world',done:false};
          hw.next();//{value:'ending',done:true};
          hw.next();//{value:'undefined',done:true};


          // 2：yield表达式
          // yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。
          var arr = [1,[[2,3],4],[5,6]];
          var flat = function* (a){
            a.forEach(function(item){
              if(typeof item !== 'number'){
                yield* flat(item);
              }else{
                yield item;
              }
            });
          }
          for(var f of flat(arr)){
            console.log(f);
          }
          //上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield表达式
          var flat = function* (a) {
            var length = a.length;
            for (var i = 0; i < length; i++) {
              var item = a[i];
              if (typeof item !== 'number') {
                yield* flat(item);
              } else {
                yield item;
              }
            }
          };

          //yeild表达式如果用在另一个表达式中，必须放在圆括号里面
          function* demo(){
            console.log('hello'+yield);//报错

            console.log('hello'+(yield));
            console.log('hello'+(yield 124));
          }
          // yield表达式作为函数参数，或者放在赋值表达式的右边，可以不加括号
          function* demo1(){
            foo(yield 'a',yield 'b');
            let input = yield;
          }


          // 3:与iterator接口的关系
          // 任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象
          //  Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。
          var myIterable = {};
          myIterable[Symbol.iterator] = function* (){
            yield 1;
            yield 2;
            yield 3;
          }
          console.log([...myIterable]);//[1,2,3];


          // 4：next方法的参数
          // yield表达式本身没有返回，或者说总是返回undefined，next方法可以带一个参数，该参数就会被当作上一个yield表达式的值
          function* foo(x){
            var y = 2 * (yield (x+1));
            var z = yield (y/3);
            return (x + y + z);
          }
          var a = foo(5);
          a.next() // Object{value:6, done:false}
          a.next() // Object{value:NaN, done:false}
          a.next() // Object{value:NaN, done:true}

          var b = foo(5);
          b.next() // { value:6, done:false }
          b.next(12) // { value:8, done:false }
          b.next(13) // { value:42, done:false }
          //如果想要第一次调用next方法，就能够输入值，可以在Generator函数外面再包一层
          function wrapper(generatorFunction){
            return function(...args){
              let generatorObject = generatorFunction(...args);
              generatorObject.next();
              return generatorObject;
            }
          }
          let wrapper = wrapper(function* (){
              console.log(`First input :${yield}`);
              return 'DONE';
          });
          // 通过next方法的参数，向 Generator 函数内部输入值的例子。
          function* dataConsumer(){
            console.log('started');
            console.log(`1.${yield}`);
            console.log(`2.${yield}`);
            return 'result';
          }
          let genObj = dataConsumer();
          genObj.next();//started;
          genObj.next('a')//1.a
          genObj.next('b')//2.b


          //4:foo...of循环
          // for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。
          function *foo() {
              yield 1;
              yield 2;
              yield 3;
              yield 4;
              yield 5;
              return 6;
            }

            for (let v of foo()) {
              console.log(v);
            }
            // 1 2 3 4 5
            // 一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。
            function* fibonacci(){
              let [prev,curr] = [0,1];
              for(;;){
                [prev,curr]= [prev,prev+curr];
                yield curr;
              }
            }
            for(let n of fibonacci()){
              if(n>1000)break;
              console.log(n);
            }
            // 利用for...of循环，可以写出遍历任意对象（object）的方法。
            // 原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。
            function* objectEntries(obj){
              let propKeys = Reflect.ownKeys(obj);
              for(let propKey of propKeys){
                yield [propKey,obj[propKey]];
              }
            }
            let jane = {first:'jane',last:'doe'};
            for(let [key,value] of objectEntries(jane)){
              console.log(`${key}: ${value}`);
            }
            // ，对象jane原生不具备 Iterator 接口，无法用for...of遍历。
            // 这时，我们通过 Generator 函数objectEntries为它加上遍历器接口，就可以用for...of遍历了。
            function* objectEntries(){
              let propKeys = Reflect.ownKeys(this);
              for(let propKey of propKeys){
                yield [propKey,this[propKey]];
              }
            }
            let jane = {first:'jane',last:'doe'};
            jane[Symbol.iterator]= objectEntries;
            for(let [key,value] of objectEntries(jane)){
              console.log(`${key}: ${value}`);
            }
            // first: Jane
            // last: Doe
            // for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。
            // 这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。
            function* numbers(){
              yield 1;
              yield 2;
              return 3;
              yield 4;
            }
            [...numbers()]//[1,2];
            Array.from(numbers());//[1,2];
            let [x,y]=numbers();
            x//1
            y//2
            for(let n of numbers()){
              console.log(n);
            }

            //5:generator.prototype.throw()
            //Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。
            var g = function* (){
              try {
                yield;
              }catch(e){
                console.log('内部捕获',e);
              }
            };
            var i = g();
            i.next();
            try{
              i.throw('a');
              i.throw('b');
            }catch(e){
              console.log('外部捕获',e);
            }
            // 内部捕获 a
            // 外部捕获 b
            // 遍历器对象 i 连续抛出两个错误，第一个错误被generator函数体内的catch语句捕获。
            // 。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，
            // 不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。
      </script>
  </body>
</html>
