<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Proxy实例的方法</title>
  </head>
  <body>
    1:get()方法有个不明白的地方，已经标注
    <script type="text/javascript">
      //1:get()  方法用于拦截某个属性的读取操作
        var person = {
          name : "张三"
        };
        var proxy = new Proxy(person,{
          get: function(target,property){
            if(property in target) {
              return target[property];
            }else{
              throw new ReferenceError("Property does not exist");
            }
          }
        });
        console.log(proxy.name);//张三
        // console.log(proxy.age);抛出一个错误
        let proto = new Proxy({},{
          get(target,property,receiver){
            console.log('GET'+property);
            return target[property];
          }
        });
        let obj = Object.create(proto);
        obj.xxx;//GETxxx;
        //上面代码中，拦截操作定义在prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效

        //下面的例子使用get拦截，实现数组读取附属的索引
        function createArray(...elements){
          let handler = {
            get(target,propKey,receiver){
              let index = Number(propKey);
              if(index < 0){
                propKey = String(target.length + index);
              }
              return Reflect.get(target,propKey,receiver);
            }
          }
          let target = [];
          target.push(...elements);
          return new Proxy(target,handler);
        };
        let arr = createArray('a','b','c');
        console.log(arr[-1]);//c
        console.log(arr[-2]);//b

        //利用proxy,可以将读取属性的操作（get),转变为执行某个函数，从而实现属性的链式操作
        // ？？？？？？？？？？？？？？？？
        var pipe = (function(){
          return function(value){
            var funcStack = [];
            var oproxy = new Proxy({},{
              get:function(pipeObject,fnName){
                if(fnName === 'get'){
                  return funcStack.reduce(function(val,fn){
                    return fn(val);
                  },value);
                }
                funcStack.push(window[fnName]);
                return oproxy;
              }
            });
            return oproxy;
          }
        }());
        var double = n => n * 2;
        var pow = n => n * n;
        var reverseInt = n => n.toString().split("").reverse().join("")|0;
        console.log(pipe(3).double.pow.reverseInt.get);//63

        //下面的例子则是利用get拦截，实现一个生成各种DOM节点的通用函数dom
        let dom = new Proxy({},{
          get(target,property){
            return function(attr = {},...children){
              let el = document.createElement(property);
              for (let prop of Object.keys(attr)){
                el.setAttribute(prop,attr[prop]);
              }
              for(let child of children){
                if(typeof child === 'string'){
                  child = document.createTextNode(child);
                }
                el.appendChild(child);
              }
              return el;
            }
          }
        });

        let el = dom.div({},
          'hello,my name is ',
          dom.a({href:'//example.com'},'mark'),
            '. i like:',
          dom.ul({},
            dom.li({},'the web'),
            dom.li({},'food'),
            dom.li({},'...actually that is ie')
          )
        );
        document.body.appendChild(el);

        //如果一个属性不可配置，和不可写，改属性不能被代理，通过proxy对象访问该属性就会报错
        let target = Object.defineProperties({},{
          foo:{
            value:123,
            writable:false,
            configuable:false
          }
        });

        let handler2 = {
          get(target,propKey){
            return 'abc';
          }
        }
        let proxy1 = new Proxy(target,handler2);
        // proxy.foo;报错


        //2：set()方法，用来拦截某个属性的赋值操作
        //假定Person对象有一个age属性，该属性应该是一个不大于200的整数，那么可以使用Proxy保证age的属性值符合要求
        let validator = {
          set:function(obj,prop,value){
            if(prop == 'age'){
              if(!Number.isInteger(value)){
                console.log('不是数值');
                return;
              }
              if(value>200){
                console.log('数值》200');
                return;
              }
            }
            //age以外的属性，直接保存
            obj[prop] = value;
          }
        };
        let person1 = new Proxy({},validator);
        person1.age = 100;
        console.log(person1.age);//100
        person1.age = 'young';//不是数值
        person1.age = 300;//数值》200
        console.log(person1.age);//100

        //注意-----------------------很重要的东西--------------
        var handler3 = {
          get(target,key){
            invariant(key,'get');
            return target[key];
          },
          set(target,key,value){
            invariant(key,'set');
            target[key] =value;
            return true;
          }
        };
        function invariant(key,action){
          if(key[0] === '_'){//第一个字符
            console.log("它是私有属性");
            return;
          }
        }
        var target1 = {};
        var proxy2 = new Proxy(target1,handler3);
        proxy2._prop; //它是私有属性
        proxy2._prop = 'c';//它是私有属性
        console.log(proxy2._prop);//c,能读出来，所以做好是抛出异常
    </script>
  </body>
</html>
