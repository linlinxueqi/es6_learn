
//--------------------------------------------------------let 命令------------------------------------------------------
{
  let a = 10;
  var b = 1;
}
console.log(b);  //1
//console.log(a);  //报错
b;
//a;  //报错

for(let i = 0;i < 10;i++){
  console.log(i);
}
//console.log(i);//报错，i  undefined

var a=[];
for(let i = 0;i < 10;i++){
  a[i] = function(){
    console.log(i);
  }
}
a[6]();
//当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。
//你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？
//这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。

var c = [];
for (var j = 0;j < 10;j++){
  c[j]=function(){
    console.log(j);
  }
}
console.log(j);
c[6]();

//j最终的数是10，是的打印出来的值都为10；
//变量j 是 var 声明的，在全局范围都有效，所以全局只有一个变量j，每次循环
//j的值都会发生改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。

for(let i = 0;i < 3;i++){
  let i='abc';
  console.log(i);
}
// 输出三次abc，并且没有报错，说明内部的变量i和外部的变量i是分离的



//---------------------------------------------------let 不存在变量提升---------------------------------------
//let命令使得它所声明的变量一定要在声明后使用，否则报错，但是var 却不会报错，值为undefined,这种现象叫做“变量提升”现象

console.log(foo);
var foo = 2;

//console.log(bar); 报错
let aaa = 3;

//-------------------------------------------------------暂时性死区------------------------------------------------

//只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部影响
//在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

var tmp = 124;
if(true){
  tmp='abc';
  //let tmp;
}
//在上面代码中，存在全局的tmp，但是在块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，
//所以在let声明变量前，对tmp赋值就会报错

// function bar(x = y,y = 2){
//   return [x,y];
// }
// bar();  x在y没有声明之前调用y，导致报错

// let x =  x;  也会报错


//---------------------------------------------------------不允许重复声明---------------------------------------------

function(){
  let a = 10;
  var a = 11;
}
function(){
  let a = 10;
  let a = 11;
}

//上面两种情况都会报错

function func(arg){
  let arg;  //报错
}

function func(arg){
  {
    let arg;  //不报错
  }
}


















//
